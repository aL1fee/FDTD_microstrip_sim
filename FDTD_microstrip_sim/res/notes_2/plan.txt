Plan:

#build a coordinate system
#do a camera
#do ok frame timing
#do simple solidworks-like camera
#memory leaks
#start imgui for the first app GUI
#threading:
	1. Main thread: window creation, event processing, high-level application logic
	2. Rendering Thread: renders the scene using OpenGL
	3. Worker Threads: physics updates, math calculations, asset loading
#placing openGL context semi-correctly
#do aspect ratio w/ correct drawing line (future ray casting) mouse pointing.



*ray casting
*draw simple polygons w/ properties



*address cpu usage & v-sync https://stackoverflow.com/questions/30381064/how-to-reduce-opengl-cpu-usage-and-or-how-to-use-opengl-properly


*make the scroll pointing to the mouse; not the front vector
*do correct window resizing

*do .frag and .vert shader files rather than .shader

*make custom polygons with defined sizes

*implement a hierarchy data structure to store elements & its properties of a scene




*shaders: https://github.com/benburrill/picoputt/tree/main


*incorporate matrix stack calls when calculating model,view,proj matrices as specified in the book


==Unsolved issues:
1. glfwpollevents doesn't run when resizing/dragging the window. As a result, key releases are not registered during resizing/dragging.
2. placing openGL context correctly
3. Worker Threads: physics updates, math calculations, asset loading




------
future:
------
* implement elaborate solidworks camera
* use qt to create a comprehensive GUI (like FreeCAD, ParaView ones)
* memory leaks


ray casting for mouse object picking https://antongerdelan.net/opengl/raycasting.html#:~:text=It%20can%20be%20useful%20to%20click%20on%2C%20or,any%20objects.%20This%20is%20usually%20called%20ray%20casting.
